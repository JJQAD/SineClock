<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sine Clock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- iOS full-screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Sine Clock" />
  <meta name="apple-mobile-web-app-orientation" content="landscape" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, sans-serif;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100vw; height:100vh; -webkit-touch-callout: none; }
    #hint {
      position: fixed;
      left: 0; right: 0;
      bottom: env(safe-area-inset-bottom, 8px);
      text-align: center;
      color: #bbb;
      font-size: 12px;
      line-height: 1.2;
      pointer-events: none;
      margin-bottom: 4px;
      display: none; /* shown only in portrait */
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js" defer></script>
</head>
<body>
  <div id="app"></div>
  <div id="hint">Sine Clock works best in landscape orientation.</div>

  <!-- Manifest injected dynamically so we can stay single-file -->
  <script>
    (function attachManifest() {
      const manifest = {
        name: "Sine Clock",
        short_name: "Sine Clock",
        display: "standalone",
        background_color: "#000000",
        theme_color: "#000000",
        orientation: "landscape",
        icons: [{ src: "", sizes: "512x512", type: "image/png", purpose: "any maskable" }]
      };
      const blob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("link");
      link.rel = "manifest";
      link.href = url;
      document.head.appendChild(link);
    })();

    function setAppIconsFromDataURL(dataURL) {
      // iOS home-screen icon
      const apple = document.createElement("link");
      apple.rel = "apple-touch-icon";
      apple.href = dataURL;
      document.head.appendChild(apple);

      // Update manifest icons dynamically
      const existing = document.querySelector('link[rel="manifest"]');
      if (existing) {
        fetch(existing.href).then(r => r.json()).then(m => {
          m.icons = [{ src: dataURL, sizes: "512x512", type: "image/png", purpose: "any maskable" }];
          const blob = new Blob([JSON.stringify(m)], { type: "application/manifest+json" });
          existing.href = URL.createObjectURL(blob);
        }).catch(()=>{});
      }
    }
  </script>

  <script>
    // ---------------- p5 sketch ----------------
    let paddingX, graphX, graphY, graphWidth, graphAmplitude;
    const lineExtension = -4;   // slight bottom overshoot
    let ampmLabel = 'AM';

    // Fixed UI gaps in px, scaled only by screen width (NOT graph height)
    function uiScale() { return Math.min(Math.max(window.innerWidth / 390, 0.9), 1.3); } // 390 ~ iPhone 12 width
    function UI(px) { return Math.round(px * uiScale()); }
    const GAPS = { title: 12, label: 12, legend: 10 };
    const TEXT_SIZE = 18;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      frameRate(30);
      angleMode(DEGREES);
      textAlign(CENTER, CENTER);
      textSize(TEXT_SIZE);
      computeLayout();
      updateHintVisibility();
      setTimeout(buildAndSetIcon, 300);  // build app icon
      registerSW();                      // PWA offline
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      computeLayout();
      updateHintVisibility();
    }

    function isPortrait() { return window.innerHeight > window.innerWidth; }
    function updateHintVisibility() {
      document.getElementById('hint').style.display = isPortrait() ? 'block' : 'none';
    }

    function computeLayout() {
      // Horizontal padding ~5–6% of width
      paddingX   = Math.min(Math.max(Math.round(width * 0.055), 10), 44);
      graphX     = paddingX;
      graphWidth = width - paddingX * 2;

      // --- Determine amplitude so the ENTIRE block fits vertically ---
      // Fixed pixel gaps (scaled by width only)
      const gapTitle  = UI(GAPS.title);
      const gapLabel  = UI(GAPS.label);
      const gapLegend = UI(GAPS.legend);
      const textH     = Math.round(TEXT_SIZE * 1.2); // reasonable line height approx

      // Grid height (topY..bottomY) = 2*A - 2*|lineExtension|
      const LEa = Math.abs(lineExtension);

      // Total block height from title line (above topY) to legend line (below numbers):
      // total = (2*A - 2*LEa) + gapTitle + gapLabel + gapLegend + textH*2
      const otherHeights = gapTitle + gapLabel + gapLegend + textH * 2;

      // Portrait: cap TOTAL block height to ~¼ of viewport width
      let maxTotalPortrait = Math.floor(width * 0.25);
      // Fallback min to avoid collapsing on very narrow screens
      maxTotalPortrait = Math.max(maxTotalPortrait, 140);

      // Start with a generous landscape amplitude (~40% of height)
      let targetA = Math.floor(height * 0.40);

      if (isPortrait()) {
        // Solve for A so total <= maxTotalPortrait:
        // 2*A - 2*LEa + otherHeights <= maxTotalPortrait
        // => A <= (maxTotalPortrait - otherHeights + 2*LEa)/2
        targetA = Math.floor((maxTotalPortrait - otherHeights + 2 * LEa) / 2);
      }

      // Also ensure it fits inside the actual viewport height (landscape small heights, etc.)
      const maxTotalByViewport = height - UI(8); // tiny safety margin
      const aByViewport = Math.floor((maxTotalByViewport - otherHeights + 2 * LEa) / 2);
      targetA = Math.min(targetA, aByViewport);

      // Clamp amplitude to sane bounds
      graphAmplitude = Math.floor(Math.min(Math.max(targetA, 48), height * 0.46));

      // Vertically center the whole block
      graphY = Math.round(height / 2);
    }

    function draw() {
      background(0);

      // Real-time angles
      const now  = new Date();
      const hr24 = now.getHours();
      const h = hr24 % 12;
      const m = now.getMinutes();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      ampmLabel = (hr24 < 12) ? 'AM' : 'PM';

      const fsec  = s + ms / 1000;
      const fmin  = m + fsec / 60;
      const fhour = h + fmin / 60;

      const minuteAngle = fmin  * 6;  // 6°/min
      const hourAngle   = fhour * 30; // 30°/hr
      const secAngle    = fsec  * 6;  // 6°/sec

      // Waves + grid
      drawMinuteWave(minuteAngle);
      drawHourWave(hourAngle);
      drawSecondsWave(secAngle);
      drawHourGrid(ampmLabel);
    }

    // -------------- Waves --------------
    function drawMinuteWave(angleDeg) {
      stroke('orange'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * cos(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * cos(angleDeg - 90);
      noStroke(); fill('orange'); circle(dotX, dotY, 10);
    }

    function drawHourWave(angleDeg) {
      stroke('red'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 90);
      noStroke(); fill('red'); circle(dotX, dotY, 10);
    }

    // Seconds wave with -240° phase
    function drawSecondsWave(angleDeg) {
      stroke(0, 200, 255); strokeWeight(2.5); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 240);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 240);
      noStroke(); fill(0, 200, 255); circle(dotX, dotY, 10);
    }

    // -------------- Grid + Labels --------------
    function drawHourGrid(ampm) {
      const bottomY = graphY + graphAmplitude - lineExtension; // fixed bottom
      const D       = Math.abs(lineExtension);
      const topY    = (graphY - graphAmplitude) - D;           // mirror above

      // Fixed pixel gaps (scaled by width only)
      const gapTitle  = UI(GAPS.title);
      const gapLabel  = UI(GAPS.label);
      const gapLegend = UI(GAPS.legend);

      const baseLabelY = bottomY + gapLabel;
      const xLeft12 = angleToX(0);
      const xEnd    = angleToX(360);

      // Minute subdivisions
      for (let i = 0; i < 12; i++) {
        const ang   = i * 30;
        const x     = angleToX(ang);
        const nextX = (i === 11) ? xEnd : angleToX(ang + 30);
        stroke(200, 200, 200, 120);
        strokeWeight(1.5);
        for (let j = 1; j <= 4; j++) {
          const interX = lerp(x, nextX, j / 5);
          line(interX, topY, interX, bottomY);
        }
      }

      // Hour lines + quarter labels
      for (let i = 0; i < 12; i++) {
        const ang = i * 30;
        const x   = angleToX(ang);
        stroke(255);
        strokeWeight(i % 3 === 0 ? 3.75 : 2.0);
        line(x, topY, x, bottomY);
        if (i % 3 === 0) {
          noStroke(); fill(255);
          const label = (i === 0) ? '12' : String(i);
          text(label, x, baseLabelY);
        }
      }

      // Duplicate right-edge 12
      stroke(255); strokeWeight(3.75);
      line(xEnd, topY, xEnd, bottomY);
      noStroke(); fill(255); text('12', xEnd, baseLabelY);

      // Title / credit / legend / AM-PM with fixed vertical spacing
      const leftEdge12 = xLeft12 - textWidth('12') / 2;
      const titleY  = topY       - gapTitle;
      const legendY = baseLabelY + gapLegend;

      // Title (left) and credit (right)
      textAlign(LEFT, CENTER);
      fill(255); text('SINE CLOCK', leftEdge12, titleY);

      textAlign(RIGHT, CENTER);
      text('JJQAD', xEnd, titleY);

      // Legend H M S (left-aligned to left edge of first '12')
      textAlign(LEFT, CENTER);
      fill('red');          text('H', leftEdge12, legendY);
      const wHspace  = textWidth('H ');
      fill('orange');       text('M', leftEdge12 + wHspace, legendY);
      const wHMspace = textWidth('H M ');
      fill(0, 200, 255);    text('S', leftEdge12 + wHMspace, legendY);

      // AM/PM aligned so the end matches the right edge of the right '12'
      textAlign(RIGHT, CENTER);
      fill(255);
      const rightEdge12 = xEnd + textWidth('12') / 2;
      text(ampm, rightEdge12, legendY);

      textAlign(CENTER, CENTER);
    }

    // -------------- Helpers --------------
    function angleToX(deg) { return map(deg, 0, 360, graphX, graphX + graphWidth); }
    function mod360(deg)   { return ((deg % 360) + 360) % 360; }

    // -------------- Dynamic app icon (phase-only offsets, same baseline, no title) --------------
    function buildAndSetIcon() {
      const size = 1024;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Background
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, size, size);

      // Same baseline for all waves; different PHASES only
      const yMid = size * 0.5;
      const amp  = size * 0.18;
      ctx.lineWidth = Math.max(8, size * 0.016);
      ctx.lineCap = 'round';

      function drawPhase(color, phaseDeg) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        for (let i = 0; i <= size; i++) {
          const t = i / size;
          const ang = t * 360;
          const y = yMid - amp * Math.sin((ang - phaseDeg) * Math.PI/180);
          if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();
      }

      // Match app phasing: orange ~ sin(ang+0), red ~ sin(ang-90), cyan ~ sin(ang-240)
      drawPhase('#ffa500',   0);   // orange (minute)
      drawPhase('#ff3b30',  90);   // red (hour)
      drawPhase('#00c8ff', 240);   // cyan (seconds)

      const dataURL = c.toDataURL('image/png');
      setAppIconsFromDataURL(dataURL);
    }

    // -------------- PWA service worker (offline cache) --------------
    function registerSW() {
      if (!('serviceWorker' in navigator)) return;
      const swCode = `
        const CACHE = 'sine-clock-v2';
        const ASSETS = [
          self.location.href,
          'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js'
        ];
        self.addEventListener('install', e => {
          e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)));
        });
        self.addEventListener('activate', e => {
          e.waitUntil(
            caches.keys().then(keys => Promise.all(keys.map(k => k === CACHE ? null : caches.delete(k))))
          );
        });
        self.addEventListener('fetch', e => {
          const req = e.request;
          e.respondWith(
            caches.match(req).then(cached => cached ||
              fetch(req).then(res => {
                if (req.method === 'GET') {
                  const copy = res.clone();
                  caches.open(CACHE).then(c => c.put(req, copy));
                }
                return res;
              }).catch(() => caches.match(self.location.href))
            )
          );
        });
      `;
      const blob = new Blob([swCode], { type: 'text/javascript' });
      const url  = URL.createObjectURL(blob);
      navigator.serviceWorker.register(url).catch(() => {});
    }
  </script>
</body>
</html>
