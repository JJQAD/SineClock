<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sine Clock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- iOS full-screen & preferred orientation (not forced) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Sine Clock" />
  <meta name="apple-mobile-web-app-orientation" content="landscape" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, sans-serif;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100vw; height:100vh; -webkit-touch-callout: none; }
    /* Portrait-only hint under the graph */
    #hint {
      position: fixed;
      left: 0; right: 0;
      bottom: env(safe-area-inset-bottom, 8px);
      text-align: center;
      color: #bbb;
      font-size: 12px;
      line-height: 1.2;
      pointer-events: none;
      margin-bottom: 4px;
      display: none; /* toggled by JS */
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js" defer></script>
</head>
<body>
  <div id="app"></div>
  <div id="hint">Sine Clock works best in landscape orientation.</div>

  <!-- Manifest is injected at runtime so this can remain a single file -->
  <script>
    (function attachManifest() {
      const manifest = {
        name: "Sine Clock",
        short_name: "Sine Clock",
        display: "standalone",
        background_color: "#000000",
        theme_color: "#000000",
        orientation: "landscape",
        icons: [{ src: "", sizes: "512x512", type: "image/png", purpose: "any maskable" }]
      };
      const blob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("link");
      link.rel = "manifest";
      link.href = url;
      document.head.appendChild(link);
    })();

    function setAppIconsFromDataURL(dataURL) {
      // iOS home-screen icon
      const apple = document.createElement("link");
      apple.rel = "apple-touch-icon";
      apple.href = dataURL;
      document.head.appendChild(apple);

      // Update manifest icons dynamically
      const existing = document.querySelector('link[rel="manifest"]');
      if (existing) {
        fetch(existing.href).then(r => r.json()).then(m => {
          m.icons = [{ src: dataURL, sizes: "512x512", type: "image/png", purpose: "any maskable" }];
          const blob = new Blob([JSON.stringify(m)], { type: "application/manifest+json" });
          existing.href = URL.createObjectURL(blob);
        }).catch(()=>{});
      }
    }
  </script>

  <script>
    // -------------- p5 sketch --------------
    let paddingX, graphX, graphY, graphWidth, graphAmplitude;
    const lineExtension = -4;   // slight bottom overshoot for grid lines
    let ampmLabel = 'AM';

    // Fixed UI gaps (in pixels, scaled lightly by width—not by graph height)
    function uiScale() { return Math.min(Math.max(window.innerWidth / 390, 0.9), 1.3); } // 390 ≈ iPhone 12 width
    function UI(px) { return Math.round(px * uiScale()); }
    const GAPS = {
      title: 12,   // distance above the grid to the title row
      label: 12,   // distance from grid bottom to the 12/3/6/9 numbers
      legend: 10   // distance from numbers to the legend row
    };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      frameRate(30);
      angleMode(DEGREES);
      textAlign(CENTER, CENTER);
      textSize(18);
      computeLayout();
      updateHintVisibility();
      // Build app icon a moment after load
      setTimeout(buildAndSetIcon, 300);
      // Register service worker (PWA/offline)
      registerSW();
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      computeLayout();
      updateHintVisibility();
    }

    function isPortrait() { return window.innerHeight > window.innerWidth; }
    function updateHintVisibility() {
      document.getElementById('hint').style.display = isPortrait() ? 'block' : 'none';
    }

    function computeLayout() {
      // Side padding ~5–6% of width; vertical padding minimized by maximizing amplitude
      paddingX   = Math.min(Math.max(Math.round(width * 0.055), 10), 44);
      graphX     = paddingX;
      graphWidth = width - paddingX * 2;

      // --- Graph height limit ---
      // Base amplitude target for generous height
      let targetAmplitude = Math.floor(height * 0.40);

      // In PORTRAIT, cap overall graph height to ~½ of viewport width
      // Total graph height ≈ 2*graphAmplitude + title/label/legend gaps (small)
      if (isPortrait()) {
        const maxTotal = Math.floor(width * 0.5);
        const fixedGaps = UI(GAPS.title + GAPS.label + GAPS.legend) + 10; // safety margin
        targetAmplitude = Math.floor(Math.max(40, (maxTotal - fixedGaps) / 2));
      }

      // Clamp amplitude to avoid clipping on extremes
      graphAmplitude = Math.floor(Math.min(Math.max(targetAmplitude, 52), height * 0.46));

      // Vertically center the graph block—spacing now uses fixed pixel gaps
      graphY = Math.round(height / 2);
    }

    function draw() {
      background(0);

      // Real-time angles
      const now  = new Date();
      const hr24 = now.getHours();
      const h = hr24 % 12;
      const m = now.getMinutes();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      ampmLabel = (hr24 < 12) ? 'AM' : 'PM';

      const fsec  = s + ms / 1000;
      const fmin  = m + fsec / 60;
      const fhour = h + fmin / 60;

      const minuteAngle = fmin  * 6;  // 6°/min
      const hourAngle   = fhour * 30; // 30°/hr
      const secAngle    = fsec  * 6;  // 6°/sec

      // Waves + grid
      drawMinuteWave(minuteAngle);
      drawHourWave(hourAngle);
      drawSecondsWave(secAngle);
      drawHourGrid(ampmLabel);
    }

    // ---------- Waves ----------
    function drawMinuteWave(angleDeg) {
      stroke('orange'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * cos(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * cos(angleDeg - 90);
      noStroke(); fill('orange'); circle(dotX, dotY, 10);
    }

    function drawHourWave(angleDeg) {
      stroke('red'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 90);
      noStroke(); fill('red'); circle(dotX, dotY, 10);
    }

    // Seconds wave with -240° phase
    function drawSecondsWave(angleDeg) {
      stroke(0, 200, 255); strokeWeight(2.5); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 240);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 240);
      noStroke(); fill(0, 200, 255); circle(dotX, dotY, 10);
    }

    // ---------- Grid + Labels ----------
    function drawHourGrid(ampm) {
      const bottomY = graphY + graphAmplitude - lineExtension;
      const D       = bottomY - (graphY + graphAmplitude);
      const topY    = (graphY - graphAmplitude) - D;

      // Use fixed pixel gaps (scaled by width only), so spacing stays consistent as graph height changes
      const baseLabelY = bottomY + UI(GAPS.label);
      const xLeft12 = angleToX(0);
      const xEnd    = angleToX(360);

      // Minute subdivisions (4 between each hour)
      for (let i = 0; i < 12; i++) {
        const ang   = i * 30;
        const x     = angleToX(ang);
        const nextX = (i === 11) ? xEnd : angleToX(ang + 30);
        stroke(200, 200, 200, 120);
        strokeWeight(1.5);
        for (let j = 1; j <= 4; j++) {
          const interX = lerp(x, nextX, j / 5);
          line(interX, topY, interX, bottomY);
        }
      }

      // Hour lines + quarter labels
      for (let i = 0; i < 12; i++) {
        const ang = i * 30;
        const x   = angleToX(ang);
        stroke(255);
        strokeWeight(i % 3 === 0 ? 3.75 : 2.0);
        line(x, topY, x, bottomY);
        if (i % 3 === 0) {
          noStroke(); fill(255);
          const label = (i === 0) ? '12' : String(i);
          text(label, x, baseLabelY);
        }
      }

      // Duplicate right-edge 12
      stroke(255); strokeWeight(3.75);
      line(xEnd, topY, xEnd, bottomY);
      noStroke(); fill(255); text('12', xEnd, baseLabelY);

      // Title / credit / legend / AM-PM with fixed gaps
      const gapTitle  = UI(GAPS.title);
      const gapLegend = UI(GAPS.legend);
      const leftEdge12 = xLeft12 - textWidth('12') / 2;
      const titleY  = topY       - gapTitle;
      const legendY = baseLabelY + gapLegend;

      // Left: SINE CLOCK
      textAlign(LEFT, CENTER);
      fill(255); text('SINE CLOCK', leftEdge12, titleY);

      // Right: JJQAD
      textAlign(RIGHT, CENTER);
      text('JJQAD', xEnd, titleY);

      // Legend H M S
      textAlign(LEFT, CENTER);
      fill('red');          text('H', leftEdge12, legendY);
      const wHspace  = textWidth('H ');
      fill('orange');       text('M', leftEdge12 + wHspace, legendY);
      const wHMspace = textWidth('H M ');
      fill(0, 200, 255);    text('S', leftEdge12 + wHMspace, legendY);

      // AM/PM: align end of label with right edge of right "12"
      textAlign(RIGHT, CENTER);
      fill(255);
      const rightEdge12 = xEnd + textWidth('12') / 2;
      text(ampm, rightEdge12, legendY);

      textAlign(CENTER, CENTER);
    }

    // ---------- Helpers ----------
    function angleToX(deg) { return map(deg, 0, 360, graphX, graphX + graphWidth); }
    function mod360(deg)   { return ((deg % 360) + 360) % 360; }

    // ---------- Dynamic app icon (single baseline, phase-only offsets, no title) ----------
    function buildAndSetIcon() {
      const size = 1024;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Background
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, size, size);

      // Single baseline; three waves only differ by PHASE (no vertical offsets)
      const yMid = size * 0.5;
      const amp  = size * 0.18;
      ctx.lineWidth = Math.max(8, size * 0.016);
      ctx.lineCap = 'round';

      function drawPhase(color, phaseDeg) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        for (let i = 0; i <= size; i++) {
          const t = i / size;
          const ang = t * 360;
          const y = yMid - amp * Math.sin((ang - phaseDeg) * Math.PI/180);
          if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();
      }

      // Phases mirroring the app: orange ~ sin(ang) (cos(ang-90)), red ~ sin(ang-90), cyan ~ sin(ang-240)
      drawPhase('#ffa500',   0);   // orange minute
      drawPhase('#ff3b30',  90);   // red hour
      drawPhase('#00c8ff', 240);   // cyan seconds

      const dataURL = c.toDataURL('image/png');
      setAppIconsFromDataURL(dataURL);
    }

    // ---------- PWA service worker (offline cache) ----------
    function registerSW() {
      if (!('serviceWorker' in navigator)) return;
      const swCode = `
        const CACHE = 'sine-clock-v1';
        const ASSETS = [
          self.location.href,
          'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js'
        ];
        self.addEventListener('install', e => {
          e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)));
        });
        self.addEventListener('activate', e => {
          e.waitUntil(
            caches.keys().then(keys => Promise.all(keys.map(k => k === CACHE ? null : caches.delete(k))))
          );
        });
        self.addEventListener('fetch', e => {
          const req = e.request;
          e.respondWith(
            caches.match(req).then(cached => cached ||
              fetch(req).then(res => {
                // cache GETs only
                if (req.method === 'GET') {
                  const copy = res.clone();
                  caches.open(CACHE).then(c => c.put(req, copy));
                }
                return res;
              }).catch(() => caches.match(self.location.href))
            )
          );
        });
      `;
      const blob = new Blob([swCode], { type: 'text/javascript' });
      const url  = URL.createObjectURL(blob);
      navigator.serviceWorker.register(url).catch(() => {});
    }
  </script>
</body>
</html>
