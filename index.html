<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sine Clock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- iOS full-screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Sine Clock" />
  <!-- Prefer landscape when installed; portrait still supported -->
  <meta name="apple-mobile-web-app-orientation" content="landscape" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, sans-serif;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100vw; height:100vh; -webkit-touch-callout: none; }
    /* Hint line below the graph */
    #hint {
      position: fixed;
      left: 0; right: 0;
      bottom: env(safe-area-inset-bottom, 12px);
      text-align: center;
      color: #bbb;
      font-size: 12px;
      line-height: 1.2;
      pointer-events: none;
      margin-bottom: 6px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js" defer></script>
</head>
<body>
  <div id="app"></div>
  <div id="hint">Sine Clock works best in landscape orientation.</div>

  <!-- Manifest is injected at runtime so this can remain one file -->
  <script>
    (function attachManifest() {
      const manifest = {
        name: "Sine Clock",
        short_name: "Sine Clock",
        display: "standalone",
        background_color: "#000000",
        theme_color: "#000000",
        orientation: "landscape",
        icons: [{ src: "", sizes: "512x512", type: "image/png", purpose: "any maskable" }]
      };
      const blob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("link");
      link.rel = "manifest";
      link.href = url;
      document.head.appendChild(link);
    })();

    function setAppIconsFromDataURL(dataURL) {
      const apple = document.createElement("link");
      apple.rel = "apple-touch-icon";
      apple.href = dataURL;
      document.head.appendChild(apple);

      const existing = document.querySelector('link[rel="manifest"]');
      if (existing) {
        fetch(existing.href).then(r => r.json()).then(m => {
          m.icons = [{ src: dataURL, sizes: "512x512", type: "image/png", purpose: "any maskable" }];
          const blob = new Blob([JSON.stringify(m)], { type: "application/manifest+json" });
          existing.href = URL.createObjectURL(blob);
        }).catch(()=>{});
      }
    }
  </script>

  <script>
    // -------------- p5 sketch --------------
    let paddingX, graphX, graphY, graphWidth, graphAmplitude;
    const lineExtension = -4;   // slight bottom overshoot
    let ampmLabel = 'AM';

    function setup() {
      createCanvas(windowWidth, windowHeight);
      frameRate(30);
      angleMode(DEGREES);
      textAlign(CENTER, CENTER);
      textSize(18);
      computeLayout();
      // Build app icon shortly after load
      setTimeout(buildAndSetIcon, 300);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      computeLayout();
    }

    function computeLayout() {
      // Side padding ~5–6% of width; vertical padding is minimized by maximizing amplitude
      paddingX   = constrain(Math.round(width * 0.055), 10, 44);
      graphX     = paddingX;
      graphWidth = width - paddingX * 2;

      // Maximize graph height: make amplitude ~40% of viewport height (capped)
      // This keeps small gaps for title/legend without clipping on all phones.
      graphAmplitude = Math.floor(constrain(height * 0.40, 60, height * 0.46));

      // Vertically center the graph block
      graphY = Math.round(height / 2);
    }

    function draw() {
      background(0);

      // Real-time angles
      const now  = new Date();
      const hr24 = now.getHours();
      const h = hr24 % 12;
      const m = now.getMinutes();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      ampmLabel = (hr24 < 12) ? 'AM' : 'PM';

      const fsec  = s + ms / 1000;
      const fmin  = m + fsec / 60;
      const fhour = h + fmin / 60;

      const minuteAngle = fmin  * 6;  // 6°/min
      const hourAngle   = fhour * 30; // 30°/hr
      const secAngle    = fsec  * 6;  // 6°/sec

      // Waves + grid
      drawMinuteWave(minuteAngle);
      drawHourWave(hourAngle);
      drawSecondsWave(secAngle);
      drawHourGrid(ampmLabel);
    }

    // ---------- Waves ----------
    function drawMinuteWave(angleDeg) {
      stroke('orange'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * cos(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * cos(angleDeg - 90);
      noStroke(); fill('orange'); circle(dotX, dotY, 10);
    }

    function drawHourWave(angleDeg) {
      stroke('red'); strokeWeight(3); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 90);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 90);
      noStroke(); fill('red'); circle(dotX, dotY, 10);
    }

    // Seconds wave with -240° phase
    function drawSecondsWave(angleDeg) {
      stroke(0, 200, 255); strokeWeight(2.5); noFill();
      beginShape();
      for (let ang = 0; ang <= 360; ang++) {
        const x = angleToX(ang);
        const y = graphY - graphAmplitude * sin(ang - 240);
        vertex(x, y);
      }
      endShape();
      const dotX = angleToX(mod360(angleDeg));
      const dotY = graphY - graphAmplitude * sin(angleDeg - 240);
      noStroke(); fill(0, 200, 255); circle(dotX, dotY, 10);
    }

    // ---------- Grid + Labels ----------
    function drawHourGrid(ampm) {
      const bottomY = graphY + graphAmplitude - lineExtension;
      const D       = bottomY - (graphY + graphAmplitude);
      const topY    = (graphY - graphAmplitude) - D;

      // Tighter internal gaps for max height
      const baseLabelY = bottomY + scaled(7);  // numbers just below bottom
      const xLeft12 = angleToX(0);
      const xEnd    = angleToX(360);

      // Minute subdivisions (4 between each hour)
      for (let i = 0; i < 12; i++) {
        const ang   = i * 30;
        const x     = angleToX(ang);
        const nextX = (i === 11) ? xEnd : angleToX(ang + 30);
        stroke(200, 200, 200, 120);
        strokeWeight(1.5);
        for (let j = 1; j <= 4; j++) {
          const interX = lerp(x, nextX, j / 5);
          line(interX, topY, interX, bottomY);
        }
      }

      // Hour lines + quarter labels
      for (let i = 0; i < 12; i++) {
        const ang = i * 30;
        const x   = angleToX(ang);
        stroke(255);
        strokeWeight(i % 3 === 0 ? 3.75 : 2.0);
        line(x, topY, x, bottomY);
        if (i % 3 === 0) {
          noStroke(); fill(255);
          const label = (i === 0) ? '12' : String(i);
          text(label, x, baseLabelY);
        }
      }

      // Duplicate right-edge 12
      stroke(255); strokeWeight(3.75);
      line(xEnd, topY, xEnd, bottomY);
      noStroke(); fill(255); text('12', xEnd, baseLabelY);

      // Title / credit / legend / AM-PM with minimal extra space
      const gap       = Math.max(6, scaled(6));  // tiny but readable
      const leftEdge12 = xLeft12 - textWidth('12') / 2;
      const titleY    = topY - gap;
      const legendY   = baseLabelY + gap;

      // Left: SINE CLOCK
      textAlign(LEFT, CENTER);
      fill(255); text('SINE CLOCK', leftEdge12, titleY);

      // Right: JJQAD
      textAlign(RIGHT, CENTER);
      text('JJQAD', xEnd, titleY);

      // Legend H M S
      textAlign(LEFT, CENTER);
      fill('red');          text('H', leftEdge12, legendY);
      const wHspace  = textWidth('H ');
      fill('orange');       text('M', leftEdge12 + wHspace, legendY);
      const wHMspace = textWidth('H M ');
      fill(0, 200, 255);    text('S', leftEdge12 + wHMspace, legendY);

      // AM/PM: align end of label with right edge of right "12"
      textAlign(RIGHT, CENTER);
      fill(255);
      const rightEdge12 = xEnd + textWidth('12') / 2;
      text(ampm, rightEdge12, legendY);

      textAlign(CENTER, CENTER);
    }

    // ---------- Helpers ----------
    function angleToX(deg) { return map(deg, 0, 360, graphX, graphX + graphWidth); }
    function mod360(deg)   { return ((deg % 360) + 360) % 360; }
    function scaled(px)    { return px * constrain(width / 390, 0.9, 1.4); } // 390 ≈ iPhone 12 width

    // ---------- Dynamic app icon with clearer wave separation ----------
    function buildAndSetIcon() {
      const size = 1024;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Background (black)
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, size, size);

      // Draw sine wave helper
      function wavePath(yMid, amp, phaseDeg) {
        ctx.beginPath();
        for (let i = 0; i <= size; i++) {
          const t = i / size;           // 0..1
          const ang = t * 360;          // degrees
          const y = yMid - amp * Math.sin((ang - phaseDeg) * Math.PI/180);
          if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
      }

      // Thicc strokes for readability
      ctx.lineWidth = Math.max(8, size * 0.016);
      ctx.lineCap = 'round';

      // Baselines and phases (offset red & orange so they don't overlap)
      const yMidOrange = size * 0.42;
      const yMidRed    = size * 0.54;
      const yMidCyan   = size * 0.48;

      // Orange (minute): cos(ang-90) ~ sin(ang+0) → phase ~ 90
      ctx.strokeStyle = '#ffa500'; wavePath(yMidOrange, size*0.18, 90); ctx.stroke();

      // Red (hour): sin(ang-90) with a slight phase offset to separate (was 90 → use 60)
      ctx.strokeStyle = '#ff3b30'; wavePath(yMidRed, size*0.16, 60); ctx.stroke();

      // Cyan (seconds): sin(ang-240)
      ctx.strokeStyle = '#00c8ff'; wavePath(yMidCyan, size*0.14, 240); ctx.stroke();

      // Title text
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.round(size*0.11)}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('Sine Clock', size/2, size*0.94);

      const dataURL = c.toDataURL('image/png');
      setAppIconsFromDataURL(dataURL);
    }
  </script>
</body>
</html>
